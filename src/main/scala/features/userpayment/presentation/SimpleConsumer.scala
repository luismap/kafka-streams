package features.userpayment.presentation

import core.infra.topics.MyKafkaConsumer
import org.apache.kafka.clients.consumer.KafkaConsumer
import org.apache.log4j.Logger

import java.time.Duration
import java.time.temporal.ChronoUnit
import java.util.Properties
import java.util.regex.Pattern
import scala.collection.convert.ImplicitConversions._
import core.infra.topics.MyKafkaConsumer

object SimpleConsumer extends App {


  val logger = Logger.getLogger(this.getClass.getName)
  val props = new Properties()
  //bring the config file autogenerated by confluent(for scala) to resources path
  props.load(this.getClass.getResourceAsStream("/secret_kafka_cluster.properties"))
  props.put("key.deserializer", "org.apache.kafka.common.serialization.StringDeserializer")
  props.put("value.deserializer", "org.apache.kafka.common.serialization.StringDeserializer")
  props.put("group.id", "simple_consumer05")

  val consumer: KafkaConsumer[String, String] = MyKafkaConsumer.consumeFrom[String, String]("poems",props)

  var keepRunning = true
  var mainThread = Thread.currentThread()

  Runtime.getRuntime().addShutdownHook(new Thread(() => {
    keepRunning = false
    logger.info("got into new thread")
    mainThread.join()
  }))

  while (keepRunning) {
    val record = consumer.poll(Duration.of(1, ChronoUnit.SECONDS))
    for (data <- record.iterator())
      logger.info(data)
  }



}
